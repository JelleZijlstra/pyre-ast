<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Parser (pyre-ast.PyreAst.Parser)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">pyre-ast</a> &#x00BB; <a href="../index.html">PyreAst</a> &#x00BB; Parser</nav><h1>Module <code>PyreAst.Parser</code></h1><p>This module contains all parsing APIs, i.e. functions that transfrom plain strings into syntactical constructs. These APIs will always hand back a <span class="xref-unresolved" title="unresolved reference to &quot;Result.t&quot;"><code>Result</code>.t</span> where if the parsing fails, a <a href="Error/index.html#type-t"><code>Parser.Error.t</code></a> gets returned.</p><p>Under the hood, this library actually compiles and calls into the actual CPython parser code, and then walks through the CPython AST translating them into OCaml structures via C bindings. This is how 100% fidelity with the official CPython implementation is achieved -- we are actually relying on exactly the same parser implementation that CPython uses. This approach has some notable implications:</p><ul><li>The parsing APIs are stateful as one need to intialize/finalize CPython runtime before invoking its parser. The low-level details are abstracted away with the <a href="Context/index.html"><code>Parser.Context</code></a> module, but the fact that no parsing can be done prior to obtaining a <a href="Context/index.html#type-t"><code>Parser.Context.t</code></a> still holds.</li><li>Text encoding support is crippled. A large part of Unicode handling in CPython is provided via extension modules, which a barely-initialized CPython runtime cannot handle. For example, Unicode character in identifier name is not allowed, and &quot;\N&quot; escape sequence in string literals are not properly translated. What's more, the <code>-*- coding: X -*-</code> header (see <a href="https://www.python.org/dev/peps/pep-0263/">PEP 263</a>) is mostly not supported unless <code>X</code> is <code>utf-8</code>.</li></ul></header><dl><dt class="spec module" id="module-Context"><a href="#module-Context" class="anchor"></a><code><span class="keyword">module</span> <a href="Context/index.html">Context</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>This module contains a type that abstracts away the details of global states required to set up the parser.</p></dd></dl><dl><dt class="spec module" id="module-Error"><a href="#module-Error" class="anchor"></a><code><span class="keyword">module</span> <a href="Error/index.html">Error</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>This module contains a type that represents parsing errors.</p></dd></dl><dl><dt class="spec value" id="val-with_context"><a href="#val-with_context" class="anchor"></a><code><span class="keyword">val</span> with_context : <span>?&#8288;on_init_failure:<span>(unit <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span>(<a href="Context/index.html#type-t">Context.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>with_context ?on_init_failure f</code> first creates a value <code>c</code> of type <a href="Context/index.html#type-t"><code>Context.t</code></a> and then invoke <code>f</code> on <code>c</code>. It is guaranteed that the created context <code>c</code> will be destroyed in the end regardless of whether <code>f</code> raises an exception or not.</p><p>If the creation of <code>c</code> fails, <code>on_init_failure ()</code> will be invoked, and <code>f</code> will not be called. By default, if not explicitly overriden then <code>on_init_failure</code> would simply raise a <code>Failure</code>.</p></dd></dl><dl><dt class="spec module" id="module-TaglessFinal"><a href="#module-TaglessFinal" class="anchor"></a><code><span class="keyword">module</span> <a href="TaglessFinal/index.html">TaglessFinal</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>This module provides parsing APIs for downstream clients that are written in tagless-final style. See <a href="../TaglessFinal/index.html"><code>PyreAst.TaglessFinal</code></a> for more explanation about this style.</p></dd></dl><dl><dt class="spec module" id="module-Concrete"><a href="#module-Concrete" class="anchor"></a><code><span class="keyword">module</span> <a href="Concrete/index.html">Concrete</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>This module provides parsing APIs for downstream clients that are written in the traditional &quot;initial&quot; style which expects a concrete ADT representation for abstract syntax trees.</p></dd></dl></div></body></html>
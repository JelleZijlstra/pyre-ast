<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>TaglessFinal (pyre-ast.PyreAst.Parser.TaglessFinal)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../../index.html">pyre-ast</a> &#x00BB; <a href="../../index.html">PyreAst</a> &#x00BB; <a href="../index.html">Parser</a> &#x00BB; TaglessFinal</nav><h1>Module <code>Parser.TaglessFinal</code></h1><p>This module provides parsing APIs for downstream clients that are written in tagless-final style. See <a href="../../TaglessFinal/index.html"><code>PyreAst.TaglessFinal</code></a> for more explanation about this style.</p><p>An implementation note: if the client provides a tagless-final specification that contains side-effects, then the order in which various syntax constructs gets recursed into by these APIs starts to matter. This library generally adopts the following order:</p><ul><li>Traversals are post-order: child constructs will be visited before the parent constructs.</li></ul><ul><li>If a parent construct contains more than one child constructs, these child constructs will be visited in their order of appearance (e.g. for <a href="../../TaglessFinal/Expression/index.html#type-t.name"><code>PyreAst.TaglessFinal.Expression.t.name</code></a>, the <code>location</code> field will be visited first, then <code>name</code>, and finally <code>ctx</code>).</li></ul><ul><li>For list-like constructs, however, the visiting order will be the <i>reverse</i> of the appearance order (e.g. when parsing a module <code>x = 1; y = 2</code>, the second statement <code>y = 2</code> will be visited before the first statement <code>x = 1</code>).</li></ul></header><dl><dt class="spec value" id="val-parse_module"><a href="#val-parse_module" class="anchor"></a><code><span class="keyword">val</span> parse_module : <span>context:<a href="../Context/index.html#type-t">Context.t</a></span> <span>&#45;&gt;</span> <span>spec:<span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">'module_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="../../TaglessFinal/index.html#type-t">TaglessFinal.t</a></span></span> <span>&#45;&gt;</span> <span>?&#8288;enable_type_comment:bool</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span>(<span class="type-var">'module_</span>, <a href="../Error/index.html#type-t">Error.t</a>)</span> Stdlib.Result.t</span></code></dt><dd><p><code>parse_module ~context ~spec input</code> takes the string <code>input</code> and parse it as Python module using tagless-final specification <code>spec</code>. See documentation of <a href="../Context/index.html#type-t"><code>Context.t</code></a> for the meaning of the <code>context</code> argument.</p><p>Optionally an <code>enable_type_comment</code> argument can be specified. If it is true, the parser will attempt to populate the <code>type_comment</code> section of each AST node that has it. Otherwise, contents in comments will all get ignored and <code>type_comment</code> will always be unset.</p></dd></dl><dl><dt class="spec value" id="val-parse_expression"><a href="#val-parse_expression" class="anchor"></a><code><span class="keyword">val</span> parse_expression : <span>context:<a href="../Context/index.html#type-t">Context.t</a></span> <span>&#45;&gt;</span> <span>spec:<span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">'expression</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="../../TaglessFinal/index.html#type-t">TaglessFinal.t</a></span></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span>(<span class="type-var">'expression</span>, <a href="../Error/index.html#type-t">Error.t</a>)</span> Stdlib.Result.t</span></code></dt><dd><p><code>parse_expression ~context ~spec input</code> takes the string <code>input</code> and parse it as Python expression using tagless-final specification <code>spec</code>. See documentation of <a href="../Context/index.html#type-t"><code>Context.t</code></a> for the meaning of the <code>context</code> argument.</p><p>Optionally an <code>enable_type_comment</code> argument can be specified. If it is true, the parser will attempt to populate the <code>type_comment</code> section of each AST node that has it. Otherwise, contents in comments will all get ignored and <code>type_comment</code> will always be unset.</p></dd></dl><dl><dt class="spec value" id="val-parse_function_type"><a href="#val-parse_function_type" class="anchor"></a><code><span class="keyword">val</span> parse_function_type : <span>context:<a href="../Context/index.html#type-t">Context.t</a></span> <span>&#45;&gt;</span> <span>spec:<span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">'function_type</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="../../TaglessFinal/index.html#type-t">TaglessFinal.t</a></span></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span>(<span class="type-var">'function_type</span>, <a href="../Error/index.html#type-t">Error.t</a>)</span> Stdlib.Result.t</span></code></dt><dd><p><code>parse_expression ~context ~spec input</code> takes the string <code>input</code> and parse it as Python function type signature using tagless-final specification <code>spec</code>. See documentation of <a href="../Context/index.html#type-t"><code>Context.t</code></a> for the meaning of the <code>context</code> argument.</p><p>Function type signature is not a reified construct in the core Python langugage. They only appears in <a href="https://www.python.org/dev/peps/pep-0484/#suggested-syntax-for-python-2-7-and-straddling-code">Python2-style typing comments</a> for functions and are superceded by the inline annotation syntax added in Python3. This API is provided here for completeness, in case downstream clients want to support the old comment-style annotation.</p></dd></dl></div></body></html>
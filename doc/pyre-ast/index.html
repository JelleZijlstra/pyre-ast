<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (pyre-ast.index)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ pyre-ast</nav><h1 id="pyre-ast"><a href="#pyre-ast" class="anchor"></a><code>pyre-ast</code></h1><p><code>pyre-ast</code> is an OCaml library to parse Python files.</p><p>The library features its full-fidelity to the official Python spec. Apart from a few technical edge cases, as long as a given file can be parsed by the CPython interpreter, <code>pyre-ast</code> will be able to parse the file without any problem. Furthermore, abstract syntax trees obtained from <code>pyre-ast</code> is guaranteed to 100% match the results obtained by Python's own <a href="https://docs.python.org/3/library/ast.html#ast.parse"><code>ast.parse</code></a> API, down to every AST node and every line and column number.</p><p>Another notable feature of this library is that it represents the Python syntax using the <a href="http://okmij.org/ftp/tagless-final/JFP.pdf">tagless-final style</a>. This style typically offers more flexibility and extensibility for the downstream consumers of the syntax, and allow them to build up their analysis without explicitly constructing a syntax tree. On the other hand, this library does offer a tranditional &quot;concrete&quot; syntax tree structure as well, for developers who are less familiar with the tagless-final approach and more familiar with standard algebraic data type representation.</p><nav class="toc"><ul><li><a href="#quick-start">Quick Start</a><ul><li><a href="#installation">Installation</a></li><li><a href="#use-in-a-dune-project">Use in a Dune project</a></li><li><a href="#parsing-apis">Parsing APIs</a></li><li><a href="#syntax-representation">Syntax Representation</a></li></ul></li><li><a href="#api-references">API References</a></li></ul></nav></header><h2 id="quick-start"><a href="#quick-start" class="anchor"></a>Quick Start</h2><h3 id="installation"><a href="#installation" class="anchor"></a>Installation</h3><p>To install <code>pyre-ast</code> with <code>opam</code>, you can run <code>opam install pyre-ast</code>.</p><h3 id="use-in-a-dune-project"><a href="#use-in-a-dune-project" class="anchor"></a>Use in a Dune project</h3><p>To use <code>pyre-ast</code> in your dune project, you can add <code>pyre-ast</code> to the <code>libraries</code> stanza in your dune file. For example,</p><pre><code class="ml">(library
  (name mylib)
  (libraries pyre-ast))</code></pre><h3 id="parsing-apis"><a href="#parsing-apis" class="anchor"></a>Parsing APIs</h3><p>All parsing APIs are located in the <a href="PyreAst/Parser/index.html"><code>PyreAst.Parser</code></a> module.</p><p>Take a look at <a href="PyreAst/Parser/Concrete/index.html"><code>PyreAst.Parser.Concrete</code></a> if all you want is to obtain a traditional abstract syntax tree. For example, the following function takes a string, parse it as a Python module, and return the corresponding AST:</p><pre><code class="ml">let example content =
  let open PyreAst.Parser in
  with_context (fun context -&gt;
  	match Concrete.parse_module ~context content with
  	| Result.Error { Error.message; line; column } -&gt;
  	  let message = 
  	    Format.sprintf &quot;Parsing error at line %d, column %d: %s&quot;
  	    message line column
  	  in
  	  failwith message
  	| Result.Ok ast -&gt; ast
  )</code></pre><p>Alternatively if you want to use the tagless-final approach, you want to use the <a href="PyreAst/Parser/TaglessFinal/index.html"><code>PyreAst.Parser.TaglessFinal</code></a> module. This module exposes the same set of interfaces as <a href="PyreAst/Parser/Concrete/index.html"><code>PyreAst.Parser.Concrete</code></a>, except each interface now takes an additional <code>spec</code> argument which reifies your downstream logic.</p><h3 id="syntax-representation"><a href="#syntax-representation" class="anchor"></a>Syntax Representation</h3><p><code>pyre-ast</code> closely mimics Python's <a href="https://docs.python.org/3/library/ast.html"><code>ast</code></a> module for its representation of the Python abstract syntax. There is almost a 1:1 correspondence between classes in the <code>ast</code> module and entities in <code>pyre-ast</code>'s interfaces. If you are unsure about the meaning of certain interface in <code>pyre-ast</code>, Python's own documentation might be a useful external reference.</p><p>As mentioned above, <code>pyre-ast</code> supports two flavors of syntax representations. The traditional &quot;concrete&quot; abstract syntax tree is defined in module <a href="PyreAst/Concrete/index.html"><code>PyreAst.Concrete</code></a>, whereas the tagless-finaly style syntax is defined in module <a href="PyreAst/TaglessFinal/index.html"><code>PyreAst.TaglessFinal</code></a>. Note that under the hood, the former is implemented on top of the latter, so only the tagless-final APIs are considered the &quot;core&quot; APIs of this library.</p><h2 id="api-references"><a href="#api-references" class="anchor"></a>API References</h2><ul class="modules"><li><a href="PyreAst/index.html"><code>PyreAst</code></a></li></ul></div></body></html>